'use strict';

/*
JavaScript
имеет функцию, известную как подразумеваемые глобальные переменные.
Всякий раз, когда используется имя, интерпретатор перемещает цепочку областей назад,
ища оператор var для этого имени. Если ни один не найден, эта переменная считается глобальной.
Если он используется в задании, глобальный создается, если он еще не существует.
Это означает, что использование или создание глобальных переменных в анонимном закрытии легко. Вот пример:

Другой популярный подход, используемый библиотеками, такими как jQuery, - глобальный импорт.
 Это похоже на анонимное замыкание, которое мы только что видели, за исключением того,
 что мы передаем глобальные переменные как параметры.
 Это необходимо для того чтобы явно указать какие переменные у нас глобальные
 (те что передаем как аргументы в IIFE), делая код внутри модуля более понятным и менее зависимым от внешних факторов.
 */
const globalVar = {};

(function (gv) {
    // Приватная функция, доступная только внутри замыкания
    const privateFn = () => console.log("Shhhh, this is private!");

    // Откроем методы через интерфейс globalVariable,
    // закрыв имплементацию внутри замыкания
    gv.greet = () => {
        privateFn();
        console.log("Hello, I am a global variable");
    };
})(globalVar);

globalVar.greet();

// Shhhh, this is private!
// Hello, I am a global variable

privateFn(); // privateFn is not defined
/*
В этом примере globalVar является единственной переменной, которая является глобальной.
Преимущество такого подхода перед анонимным замыкание заключается в том,
что вы объявляете глобальные переменные наперед,
что делает код значительно более читабельным,
так как имена использующихся переменных указаны явно.
 */